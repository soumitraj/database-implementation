!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
Add	DBFile.cc	/^void DBFile::Add (Record &rec) {$/;"	f	class:DBFile
AddLitToFile	Comparison.cc	/^void AddLitToFile (int &numFieldsInLiteral, FILE *outRecFile, FILE *outSchemaFile, char *value, Type myType) {$/;"	f
AddPage	File.cc	/^void File :: AddPage (Page *addMe, off_t whichPage) {$/;"	f	class:File
Advance	TwoWayList.cc	/^TwoWayList <Type> :: Advance ()$/;"	f	class:TwoWayList
AndList	ParseTree.h	/^struct AndList {$/;"	s
AndList	Parser.y	/^AndList: '(' OrList ')' AND AndList$/;"	l
Append	File.cc	/^int Page :: Append (Record *addMe) {$/;"	f	class:Page
Attribute	Schema.h	/^struct Attribute {$/;"	s
BIGQ_H	BigQ.h	2;"	d
BigQ	BigQ.cc	/^BigQ :: BigQ (Pipe &in, Pipe &out, OrderMaker &sortorder, int runlen) {$/;"	f	class:BigQ
BigQ	BigQ.h	/^class BigQ {$/;"	c
CC	Makefile	/^CC = g++ -g -Wno-deprecated$/;"	m
CNF	Comparison.h	/^class CNF {$/;"	c
COMPARISON_H	Comparison.h	2;"	d
Close	DBFile.cc	/^int DBFile::Close () {$/;"	f	class:DBFile
Close	File.cc	/^int File :: Close () {$/;"	f	class:File
CompOperator	Defs.h	/^enum CompOperator {LessThan, GreaterThan, Equals};$/;"	g
Compare	ComparisonEngine.cc	/^int ComparisonEngine :: Compare (Record *left, OrderMaker *order_left, Record *right, OrderMaker *order_right) {$/;"	f	class:ComparisonEngine
Compare	ComparisonEngine.cc	/^int ComparisonEngine :: Compare (Record *left, Record *literal, CNF *myComparison) {$/;"	f	class:ComparisonEngine
Compare	ComparisonEngine.cc	/^int ComparisonEngine :: Compare (Record *left, Record *right, Record *literal, CNF *myComparison) {$/;"	f	class:ComparisonEngine
Compare	ComparisonEngine.cc	/^int ComparisonEngine :: Compare(Record *left, Record *right, OrderMaker *orderUs) {$/;"	f	class:ComparisonEngine
Comparison	Comparison.cc	/^Comparison::Comparison()$/;"	f	class:Comparison
Comparison	Comparison.cc	/^Comparison::Comparison(const Comparison &copy_me)$/;"	f	class:Comparison
Comparison	Comparison.h	/^class Comparison {$/;"	c
ComparisonEngine	ComparisonEngine.h	/^class ComparisonEngine {$/;"	c
ComparisonOp	ParseTree.h	/^struct ComparisonOp {$/;"	s
Condition	Parser.y	/^Condition: Literal Op Literal $/;"	l
Consume	Record.cc	/^void Record :: Consume (Record *fromMe) {$/;"	f	class:Record
Copy	Record.cc	/^void Record :: Copy (Record *copyMe) {$/;"	f	class:Record
CopyBits	Record.cc	/^void Record :: CopyBits(char *bits, int b_len) {$/;"	f	class:Record
Create	DBFile.cc	/^int DBFile::Create (char *f_path, fType f_type, void *startup) {$/;"	f	class:DBFile
Current	TwoWayList.cc	/^TwoWayList <Type> ::  Current (int offset)$/;"	f	class:TwoWayList
DBFILE_H	DBFile.h	2;"	d
DBFile	DBFile.cc	/^DBFile::DBFile () {$/;"	f	class:DBFile
DBFile	DBFile.h	/^class DBFile {$/;"	c
DEFS_H	Defs.h	2;"	d
DOUBLE	ParseTree.h	9;"	d
Double	Defs.h	/^enum Type {Int, Double, String};$/;"	e	enum:Type
EQUALS	ParseTree.h	6;"	d
EmptyItOut	File.cc	/^void Page :: EmptyItOut () {$/;"	f	class:Page
Equals	Defs.h	/^enum CompOperator {LessThan, GreaterThan, Equals};$/;"	e	enum:CompOperator
FILE_H	File.h	2;"	d
File	File.cc	/^File :: File () {$/;"	f	class:File
File	File.h	/^class File {$/;"	c
Find	Schema.cc	/^int Schema :: Find (char *attName) {$/;"	f	class:Schema
FindType	Schema.cc	/^Type Schema :: FindType (char *attName) {$/;"	f	class:Schema
FromBinary	File.cc	/^void Page :: FromBinary (char *bits) {$/;"	f	class:Page
GREATER_THAN	ParseTree.h	5;"	d
GetAtts	Schema.cc	/^Attribute *Schema :: GetAtts () {$/;"	f	class:Schema
GetBits	Record.cc	/^char* Record :: GetBits (void) {$/;"	f	class:Record
GetFirst	File.cc	/^int Page :: GetFirst (Record *firstOne) {$/;"	f	class:Page
GetLength	File.cc	/^off_t File :: GetLength () {$/;"	f	class:File
GetNext	DBFile.cc	/^int DBFile::GetNext (Record &fetchme) {$/;"	f	class:DBFile
GetNext	DBFile.cc	/^int DBFile::GetNext (Record &fetchme, CNF &cnf, Record &literal) {$/;"	f	class:DBFile
GetNumAtts	Schema.cc	/^int Schema :: GetNumAtts () {$/;"	f	class:Schema
GetPage	File.cc	/^void File :: GetPage (Page *putItHere, off_t whichPage) {$/;"	f	class:File
GetSortOrders	Comparison.cc	/^int CNF :: GetSortOrders (OrderMaker &left, OrderMaker &right) {$/;"	f	class:CNF
GreaterThan	Defs.h	/^enum CompOperator {LessThan, GreaterThan, Equals};$/;"	e	enum:CompOperator
GrowFromParseTree	Comparison.cc	/^void CNF :: GrowFromParseTree (struct AndList *parseTree, Schema *leftSchema, $/;"	f	class:CNF
GrowFromParseTree	Comparison.cc	/^void CNF :: GrowFromParseTree (struct AndList *parseTree, Schema *mySchema, $/;"	f	class:CNF
Header	TwoWayList.h	/^		struct Header {$/;"	s	class:TwoWayList
INT	ParseTree.h	10;"	d
Insert	Pipe.cc	/^void Pipe :: Insert (Record *insertMe) {$/;"	f	class:Pipe
Insert	TwoWayList.cc	/^TwoWayList <Type> :: Insert (Type *Item)$/;"	f	class:TwoWayList
Int	Defs.h	/^enum Type {Int, Double, String};$/;"	e	enum:Type
LESS_THAN	ParseTree.h	4;"	d
Left	Defs.h	/^enum Target {Left, Right, Literal};$/;"	e	enum:Target
LeftLength	TwoWayList.cc	/^TwoWayList <Type> :: LeftLength ()$/;"	f	class:TwoWayList
LessThan	Defs.h	/^enum CompOperator {LessThan, GreaterThan, Equals};$/;"	e	enum:CompOperator
Literal	Defs.h	/^enum Target {Left, Right, Literal};$/;"	e	enum:Target
Literal	Parser.y	/^Literal : String $/;"	l
Load	DBFile.cc	/^void DBFile::Load (Schema &f_schema, char *loadpath) {$/;"	f	class:DBFile
MAX_ANDS	Defs.h	5;"	d
MAX_ORS	Defs.h	6;"	d
MergeRecords	Record.cc	/^void Record :: MergeRecords (Record *left, Record *right, int numAttsLeft, int numAttsRight, int *attsToKeep, int numAttsToKeep, int startOfRight) {$/;"	f	class:Record
MoveFirst	DBFile.cc	/^void DBFile::MoveFirst () {$/;"	f	class:DBFile
MoveToFinish	TwoWayList.cc	/^TwoWayList <Type> :: MoveToFinish ()$/;"	f	class:TwoWayList
MoveToStart	TwoWayList.cc	/^TwoWayList <Type> :: MoveToStart ()$/;"	f	class:TwoWayList
NAME	ParseTree.h	12;"	d
Node	TwoWayList.h	/^			Node () : data (0), next (0), previous (0) {}$/;"	f	struct:TwoWayList::Node
Node	TwoWayList.h	/^		struct Node {$/;"	s	class:TwoWayList
Op	Parser.y	/^Op: '<' $/;"	l
Open	DBFile.cc	/^int DBFile::Open (char *f_path) {$/;"	f	class:DBFile
Open	File.cc	/^void File :: Open (int fileLen, char *fName) {$/;"	f	class:File
Operand	ParseTree.h	/^struct Operand {$/;"	s
OrList	ParseTree.h	/^struct OrList {$/;"	s
OrList	Parser.y	/^OrList: Condition OR OrList$/;"	l
OrderMaker	Comparison.cc	/^OrderMaker :: OrderMaker() {$/;"	f	class:OrderMaker
OrderMaker	Comparison.cc	/^OrderMaker :: OrderMaker(Schema *schema) {$/;"	f	class:OrderMaker
OrderMaker	Comparison.h	/^class OrderMaker {$/;"	c
PAGE_SIZE	Defs.h	8;"	d
PIPE_H	Pipe.h	2;"	d
Page	File.cc	/^Page :: Page () {$/;"	f	class:Page
Page	File.h	/^class Page {$/;"	c
Pipe	Pipe.cc	/^Pipe :: Pipe (int bufferSize) {$/;"	f	class:Pipe
Pipe	Pipe.h	/^class Pipe {$/;"	c
Print	Comparison.cc	/^void CNF :: Print () {$/;"	f	class:CNF
Print	Comparison.cc	/^void Comparison :: Print () {$/;"	f	class:Comparison
Print	Comparison.cc	/^void OrderMaker :: Print () {$/;"	f	class:OrderMaker
Print	Record.cc	/^void Record :: Print (Schema *mySchema) {$/;"	f	class:Record
Project	Record.cc	/^void Record :: Project (int *attsToKeep, int numAttsToKeep, int numAttsNow) {$/;"	f	class:Record
RECORD_H	Record.h	2;"	d
Record	Record.cc	/^Record :: Record () {$/;"	f	class:Record
Record	Record.h	/^class Record {$/;"	c
Remove	Pipe.cc	/^int Pipe :: Remove (Record *removeMe) {$/;"	f	class:Pipe
Remove	TwoWayList.cc	/^TwoWayList <Type> :: Remove (Type *Item)$/;"	f	class:TwoWayList
Retreat	TwoWayList.cc	/^TwoWayList <Type> :: Retreat ()$/;"	f	class:TwoWayList
Right	Defs.h	/^enum Target {Left, Right, Literal};$/;"	e	enum:Target
RightLength	TwoWayList.cc	/^TwoWayList <Type> :: RightLength ()$/;"	f	class:TwoWayList
Run	ComparisonEngine.cc	/^int ComparisonEngine :: Run (Record *left, Record *literal, Comparison *c) {$/;"	f	class:ComparisonEngine
Run	ComparisonEngine.cc	/^int ComparisonEngine :: Run (Record *left, Record *right, Record *literal, Comparison *c) {$/;"	f	class:ComparisonEngine
SCHEMA_H	Schema.h	3;"	d
STRING	ParseTree.h	11;"	d
Schema	Schema.cc	/^Schema :: Schema (char *fName, char *relName) {$/;"	f	class:Schema
Schema	Schema.h	/^class Schema {$/;"	c
SetBits	Record.cc	/^void Record :: SetBits (char *bits) {$/;"	f	class:Record
ShutDown	Pipe.cc	/^void Pipe :: ShutDown () {$/;"	f	class:Pipe
String	Defs.h	/^enum Type {Int, Double, String};$/;"	e	enum:Type
SuckNextRecord	Record.cc	/^int Record :: SuckNextRecord (Schema *mySchema, FILE *textFile) {$/;"	f	class:Record
SwapLefts	TwoWayList.cc	/^TwoWayList <Type> :: SwapLefts (TwoWayList & List)$/;"	f	class:TwoWayList
SwapRights	TwoWayList.cc	/^TwoWayList <Type> :: SwapRights (TwoWayList & List)$/;"	f	class:TwoWayList
TEST_H	test.h	2;"	d
Target	Defs.h	/^enum Target {Left, Right, Literal};$/;"	g
ToBinary	File.cc	/^void Page :: ToBinary (char *bits) {$/;"	f	class:Page
TwoWayList	TwoWayList.cc	/^TwoWayList <Type> :: TwoWayList ()$/;"	f	class:TwoWayList
TwoWayList	TwoWayList.cc	/^TwoWayList <Type> :: TwoWayList (TwoWayList &me) {$/;"	f	class:TwoWayList
TwoWayList	TwoWayList.h	/^class TwoWayList {$/;"	c
Type	Defs.h	/^enum Type {Int, Double, String};$/;"	g
_ENGINE	ComparisonEngine.h	2;"	d
_TWO_WAY_LIST_C	TwoWayList.cc	2;"	d	file:
_TWO_WAY_LIST_H	TwoWayList.h	2;"	d
add_data	test.cc	/^int add_data (FILE *src, int numrecs, int &res) {$/;"	f
attType	Comparison.h	/^	Type attType;$/;"	m	class:Comparison
bits	Record.h	/^	char *bits;$/;"	m	class:Record
buffered	Pipe.h	/^	Record *buffered;$/;"	m	class:Pipe
c	test.h	/^relation *s, *p, *ps, *n, *li, *r, *o, *c;$/;"	v
catalog_path	test.h	/^char *catalog_path = "catalog"; $/;"	v
cleanup	test.h	/^void cleanup () {$/;"	f
code	ParseTree.h	/^	int code;$/;"	m	struct:ComparisonOp
code	ParseTree.h	/^	int code;$/;"	m	struct:Operand
consumerVar	Pipe.h	/^	pthread_cond_t consumerVar;$/;"	m	class:Pipe
curLength	File.h	/^	off_t curLength; \/\/this was private in Chris's version$/;"	m	class:File
curSizeInBytes	File.h	/^	int curSizeInBytes;$/;"	m	class:Page
current	TwoWayList.h	/^			Node * current;$/;"	m	struct:TwoWayList::Header
customer	test.h	/^char *customer = "customer"; $/;"	v
data	TwoWayList.h	/^			Type *data;$/;"	m	struct:TwoWayList::Node
dbfile_dir	test.h	/^char *dbfile_dir = ""; $/;"	v
done	Pipe.h	/^	int done;$/;"	m	class:Pipe
fType	DBFile.h	/^typedef enum {heap, sorted, tree} fType;$/;"	t	typeref:enum:__anon2
fileName	Schema.h	/^	char *fileName;$/;"	m	class:Schema
first	TwoWayList.h	/^			Node * first;$/;"	m	struct:TwoWayList::Header
firstSlot	Pipe.h	/^	int firstSlot;$/;"	m	class:Pipe
get_cnf	test.h	/^	void get_cnf (CNF &cnf_pred, Record &literal) {$/;"	f	class:relation
get_sort_order	test.h	/^	void get_sort_order (OrderMaker &sortorder) {$/;"	f	class:relation
heap	DBFile.h	/^typedef enum {heap, sorted, tree} fType;$/;"	e	enum:__anon2
info	test.h	/^	void info () {$/;"	f	class:relation
last	TwoWayList.h	/^			Node * last;$/;"	m	struct:TwoWayList::Header
lastSlot	Pipe.h	/^	int lastSlot;$/;"	m	class:Pipe
left	ParseTree.h	/^	struct ComparisonOp *left;$/;"	m	struct:OrList	typeref:struct:OrList::ComparisonOp
left	ParseTree.h	/^	struct Operand *left;$/;"	m	struct:ComparisonOp	typeref:struct:ComparisonOp::Operand
left	ParseTree.h	/^	struct OrList *left;$/;"	m	struct:AndList	typeref:struct:AndList::OrList
leftSize	TwoWayList.h	/^			int leftSize;$/;"	m	struct:TwoWayList::Header
li	test.h	/^relation *s, *p, *ps, *n, *li, *r, *o, *c;$/;"	v
lineitem	test.h	/^char *lineitem = "lineitem"; $/;"	v
list	TwoWayList.h	/^		Header *list;	$/;"	m	class:TwoWayList
main	test.cc	/^int main (int argc, char *argv[]) {$/;"	f
myAtts	Schema.h	/^	Attribute *myAtts;$/;"	m	class:Schema
myFilDes	File.h	/^	int myFilDes;$/;"	m	class:File
myRecs	File.h	/^	TwoWayList <Record> *myRecs;$/;"	m	class:Page
myType	Schema.h	/^	Type myType;$/;"	m	struct:Attribute
n	test.h	/^relation *s, *p, *ps, *n, *li, *r, *o, *c;$/;"	v
name	Schema.h	/^	char *name;$/;"	m	struct:Attribute
name	test.h	/^	char* name () { return rname; }$/;"	f	class:relation
nation	test.h	/^char *nation = "nation"; $/;"	v
next	TwoWayList.h	/^			Node *next;$/;"	m	struct:TwoWayList::Node
numAnds	Comparison.h	/^	int numAnds;$/;"	m	class:CNF
numAtts	Comparison.h	/^	int numAtts;$/;"	m	class:OrderMaker
numAtts	Schema.h	/^	int numAtts;$/;"	m	class:Schema
numRecs	File.h	/^	int numRecs;$/;"	m	class:Page
o	test.h	/^relation *s, *p, *ps, *n, *li, *r, *o, *c;$/;"	v
op	Comparison.h	/^	CompOperator op;$/;"	m	class:Comparison
operand1	Comparison.h	/^	Target operand1;$/;"	m	class:Comparison
operand2	Comparison.h	/^	Target operand2;$/;"	m	class:Comparison
operator &=	TwoWayList.cc	/^TwoWayList <Type> :: operator &= (TwoWayList & List)$/;"	f	class:TwoWayList
orLens	Comparison.h	/^	int orLens[MAX_ANDS];$/;"	m	class:CNF
orList	Comparison.h	/^	Comparison orList[MAX_ANDS][MAX_ORS];$/;"	m	class:CNF
order	test.h	/^	OrderMaker *order;$/;"	m	struct:__anon1
orders	test.h	/^char *orders = "orders"; $/;"	v
p	test.h	/^relation *s, *p, *ps, *n, *li, *r, *o, *c;$/;"	v
part	test.h	/^char *part = "part"; $/;"	v
partsupp	test.h	/^char *partsupp = "partsupp"; $/;"	v
path	test.h	/^	char* path () { return rpath; }$/;"	f	class:relation
pipe	test.h	/^	Pipe *pipe;$/;"	m	struct:__anon1
pipeMutex	Pipe.h	/^	pthread_mutex_t pipeMutex;$/;"	m	class:Pipe
prefix	test.h	/^	char *prefix;$/;"	m	class:relation
previous	TwoWayList.h	/^			Node *previous;$/;"	m	struct:TwoWayList::Node
print	test.h	/^	bool print;$/;"	m	struct:__anon1
producerVar	Pipe.h	/^	pthread_cond_t producerVar;$/;"	m	class:Pipe
ps	test.h	/^relation *s, *p, *ps, *n, *li, *r, *o, *c;$/;"	v
r	test.h	/^relation *s, *p, *ps, *n, *li, *r, *o, *c;$/;"	v
region	test.h	/^char *region = "region"; $/;"	v
rel	test.h	/^relation *rel;$/;"	v
relation	test.h	/^	relation (char *_name, Schema *_schema, char *_prefix) :$/;"	f	class:relation
relation	test.h	/^class relation {$/;"	c
right	ParseTree.h	/^	struct Operand *right;	$/;"	m	struct:ComparisonOp	typeref:struct:ComparisonOp::Operand
rightAnd	ParseTree.h	/^	struct AndList *rightAnd;$/;"	m	struct:AndList	typeref:struct:AndList::AndList
rightOr	ParseTree.h	/^	struct OrList *rightOr;$/;"	m	struct:OrList	typeref:struct:OrList::OrList
rightSize	TwoWayList.h	/^			int rightSize;$/;"	m	struct:TwoWayList::Header
rname	test.h	/^	char *rname;$/;"	m	class:relation
rpath	test.h	/^	char rpath[100]; $/;"	m	class:relation
rschema	test.h	/^	Schema *rschema;$/;"	m	class:relation
s	test.h	/^relation *s, *p, *ps, *n, *li, *r, *o, *c;$/;"	v
schema	test.h	/^	Schema* schema () { return rschema;}$/;"	f	class:relation
setup	test.h	/^void setup () {$/;"	f
sorted	DBFile.h	/^typedef enum {heap, sorted, tree} fType;$/;"	e	enum:__anon2
supplier	test.h	/^char *supplier = "supplier"; $/;"	v
tag	Makefile	/^tag = -i$/;"	m
tag	Makefile	/^tag = -n$/;"	m
test1	test.cc	/^void test1 () {$/;"	f
test2	test.cc	/^void test2 () {$/;"	f
test3	test.cc	/^void test3 () {$/;"	f
testutil	test.h	/^}testutil;$/;"	t	typeref:struct:__anon1
totSpace	Pipe.h	/^	int totSpace;$/;"	m	class:Pipe
tpch_dir	test.h	/^char *tpch_dir ="\/cise\/tmp\/dbi_sp11\/DATA\/1G\/"; $/;"	v
tree	DBFile.h	/^typedef enum {heap, sorted, tree} fType;$/;"	e	enum:__anon2
value	ParseTree.h	/^	char *value;$/;"	m	struct:Operand
whichAtt1	Comparison.h	/^	int whichAtt1;$/;"	m	class:Comparison
whichAtt2	Comparison.h	/^	int whichAtt2;$/;"	m	class:Comparison
whichAtts	Comparison.h	/^	int whichAtts[MAX_ANDS];$/;"	m	class:OrderMaker
whichTypes	Comparison.h	/^	Type whichTypes[MAX_ANDS];$/;"	m	class:OrderMaker
write	test.h	/^	bool write;$/;"	m	struct:__anon1
~BigQ	BigQ.cc	/^BigQ::~BigQ () {$/;"	f	class:BigQ
~File	File.cc	/^File :: ~File () {$/;"	f	class:File
~Node	TwoWayList.h	/^			~Node () $/;"	f	struct:TwoWayList::Node
~Page	File.cc	/^Page :: ~Page () {$/;"	f	class:Page
~Pipe	Pipe.cc	/^Pipe :: ~Pipe () {$/;"	f	class:Pipe
~Record	Record.cc	/^Record :: ~Record () {$/;"	f	class:Record
~Schema	Schema.cc	/^Schema :: ~Schema () {$/;"	f	class:Schema
~TwoWayList	TwoWayList.cc	/^TwoWayList <Type> :: ~TwoWayList ()$/;"	f	class:TwoWayList
